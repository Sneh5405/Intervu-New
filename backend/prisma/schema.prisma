// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum Role {
  INTERVIEWEE
  INTERVIEWER
  HR
}

enum QuestionType {
  MCQ
  SCENARIO
  CODE
}

enum QuestionDifficulty {
  EASY
  MEDIUM
  HARD
}

enum InterviewStatus {
  SCHEDULED
  COMPLETED
  CANCELLED
  MOVED_TO_NEXT_ROUND
}

enum UserStatus {
  ACTIVE
  BLOCKED
}

// Models
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  password String
  name  String?
  role  Role    @default(INTERVIEWEE)
  status UserStatus @default(ACTIVE)
  emailVerified Boolean @default(false)
  emailOtp EmailOtp?
  
  refreshToken RefreshToken?

  interviewsAsHr          Interview[] @relation("HrInterviews")
  interviewsAsInterviewer Interview[] @relation("InterviewerInterviews")
  interviewsAsInterviewee Interview[] @relation("IntervieweeInterviews")
  questionsCreated        Question[]  @relation("CreatedQuestions")
}

model EmailOtp {
  id        Int      @id @default(autoincrement())
  otpHash   String
  expiresAt DateTime

  userId    Int      @unique
  user      User     @relation(fields: [userId], references: [id])
}


model RefreshToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  device    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  userId    Int      @unique
  user      User     @relation(fields: [userId], references: [id])
}


model Interview {
  id        Int             @id @default(autoincrement())
  startTime DateTime
  endTime   DateTime
  status    InterviewStatus @default(SCHEDULED)
  round     Int             @default(1)
  meetLink  String?

  // Relations
  hrId          Int
  hr            User @relation("HrInterviews", fields: [hrId], references: [id])
  interviewerId Int
  interviewer   User @relation("InterviewerInterviews", fields: [interviewerId], references: [id])
  intervieweeId Int
  interviewee   User @relation("IntervieweeInterviews", fields: [intervieweeId], references: [id])

  questions InterviewQuestion[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?
}

model Question {
  id            Int          @id @default(autoincrement())
  text          String
  type          QuestionType
  options       Json? // For MCQ options
  correctAnswer String? // Could be text or JSON depending on complexity
  testCases     Json? // For Code questions
  difficulty    QuestionDifficulty @default(MEDIUM)
  tags          String[]
  deletedAt     DateTime?

  // Relations
  createdById Int
  createdBy   User @relation("CreatedQuestions", fields: [createdById], references: [id])

  interviews InterviewQuestion[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model InterviewQuestion {
  id       Int     @id @default(autoincrement())
  order    Int? // To order questions in the interview
  isAsked  Boolean @default(false)
  feedback String? // Interviewer's notes/feedback or score for this specific question
  
  candidateAnswer String? // Code or MCQ option
  submittedAt     DateTime?

  interviewId Int
  interview   Interview @relation(fields: [interviewId], references: [id])

  questionId Int
  question   Question @relation(fields: [questionId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([interviewId, questionId]) // Prevent duplicate question assignment to same interview? Or allow if they can ask again? Assuming unique for now.
}
